<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Roof Measurement Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 400px;
            background: white;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .header h1 {
            font-size: 20px;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .header p {
            color: #6b7280;
            font-size: 14px;
        }
        
        /* Property Address Section */
        .section {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .section-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 12px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title::before {
            content: "üè†";
        }
        
        .address-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 12px;
        }
        
        .load-btn {
            width: 100%;
            padding: 12px;
            background: #374151;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .load-btn:hover {
            background: #4b5563;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .load-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .load-btn.loading {
            background: #6b7280;
            cursor: not-allowed;
            animation: loadingPulse 1.5s infinite;
        }
        
        @keyframes loadingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Measurement Tools */
        .measurement-tools .section-title::before {
            content: "üìè";
        }
        
        .measurement-types {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .type-btn {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            color: white;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .type-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .type-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Button click animation */
        .type-btn.clicked {
            animation: buttonPulse 0.3s ease;
        }
        
        @keyframes buttonPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .type-btn.perimeter {
            background: #ef4444;
        }
        
        .type-btn.ridge {
            background: #3b82f6;
        }
        
        .type-btn.ground {
            background: #10b981;
        }
        
        .type-btn.zoom {
            background: #f59e0b;
        }
        
        
        .type-btn.active {
            opacity: 1;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.8);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .start-btn {
            width: 100%;
            padding: 12px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .start-btn:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .start-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .start-btn.active-measuring {
            background: #ef4444;
            animation: measuring 2s infinite alternate;
        }
        
        @keyframes measuring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            100% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }
        
        .control-row {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            flex: 1;
            padding: 10px;
            background: #f3f4f6;
            color: #374151;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .control-btn:hover {
            background: #e5e7eb;
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Custom Google Maps Controls */
        .zoom-area-control {
            background: #fff;
            border: 2px solid rgba(0,0,0,0.3);
            border-radius: 3px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            margin: 2px 0;
            text-align: center;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s;
        }
        
        .zoom-area-control:hover {
            background: #f5f5f5;
            border-color: rgba(0,0,0,0.5);
        }
        
        .zoom-area-control:active {
            background: #e5e5e5;
        }
        
        .zoom-area-control.active {
            background: #f59e0b;
            color: white;
            border-color: #f59e0b;
        }
        
        /* Distance Results */
        .distance-results .section-title::before {
            content: "üìä";
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid;
        }
        
        .result-item.perimeter {
            border-left-color: #ef4444;
        }
        
        .result-item.ridge {
            border-left-color: #3b82f6;
        }
        
        .result-item.ground {
            border-left-color: #10b981;
        }
        
        .result-item.total {
            background: #1f2937;
            color: white;
            border-left-color: #1f2937;
        }
        
        .result-label {
            font-weight: 500;
        }
        
        .result-value {
            font-weight: 600;
        }
        
        /* Material Calculator */
        .material-calculator .section-title::before {
            content: "üí°";
        }
        
        .calculator-config {
            background: #f3f4f6;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .config-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .config-row:last-child {
            margin-bottom: 0;
        }
        
        .config-group {
            flex: 1;
        }
        
        .config-label {
            display: block;
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            font-weight: 500;
        }
        
        .config-select, .config-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Ensure artificial zoom transforms work properly */
        .gm-style > div:first-child {
            transform-origin: center center !important;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: #f9fafb;
            color: #6b7280;
            font-size: 16px;
        }
        
        /* Live Stats Overlay */
        .live-stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 200px;
            display: none;
        }
        
        .live-stats h4 {
            margin-bottom: 12px;
            color: #1f2937;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .stat-label {
            color: #6b7280;
            font-size: 14px;
        }
        
        .stat-value {
            font-weight: 600;
            color: #1f2937;
        }
        
        .no-measurements {
            color: #9ca3af;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 50vh;
            }
            
            .map-container {
                flex: 1;
                min-height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Header -->
            <div class="header">
                <h1>Measurement</h1>
                <p>Measure roof lines and calculate materials</p>
            </div>
            
            <!-- Property Address -->
            <div class="section">
                <div class="section-title">Property Address</div>
                <input 
                    type="text" 
                    class="address-input" 
                    id="address-input"
                    placeholder="Enter the address to load satellite imagery for measurement"
                    value="5506 E County Rd 60, Midland, TX 79705, USA"
                />
                <button class="load-btn" onclick="searchAddress()">
                    üè† Load Property
                </button>
            </div>
            
            <!-- Measurement Tools -->
            <div class="section measurement-tools">
                <div class="section-title">Measurement Tools</div>
                <p style="color: #6b7280; font-size: 12px; margin-bottom: 12px;">Select type and control drawing</p>
                
                <div class="measurement-types">
                    <button class="type-btn perimeter active" onclick="setType('perimeter')">
                        üî¥ Perimeter
                    </button>
                    <button class="type-btn ridge" onclick="setType('ridge')">
                        üîµ Ridge
                    </button>
                    <button class="type-btn ground" onclick="setType('ground')">
                        üü¢ Ground
                    </button>
                    <button class="type-btn zoom" onclick="activateZoomTool()">
                        üîç Zoom Tool
                    </button>
                </div>
                
                
                <div class="controls">
                    <button class="start-btn" id="start-btn" onclick="startMeasuring()">
                        üìè Start Measuring
                    </button>
                    <div class="control-row" id="control-row" style="display: none;">
                        <button class="control-btn" onclick="undoPoint()">‚Ü©Ô∏è Undo</button>
                        <button class="control-btn" onclick="clearCurrent()">üóëÔ∏è Clear</button>
                        <button class="control-btn" onclick="saveMeasurement()">üíæ Save</button>
                    </div>
                </div>
            </div>
            
            <!-- Distance Results -->
            <div class="section distance-results">
                <div class="section-title">Distance Results</div>
                <div id="distance-results">
                    <div class="no-measurements">No measurements yet</div>
                </div>
            </div>
            
            <!-- Material Calculator -->
            <div class="section material-calculator">
                <div class="section-title">Material Calculator</div>
                
                <div class="calculator-config">
                    <div class="config-row">
                        <div class="config-group">
                            <label class="config-label">Stories</label>
                            <select class="config-select" id="stories" onchange="updateMaterialEstimate()">
                                <option value="1">1 Story</option>
                                <option value="2">2 Story</option>
                                <option value="3">3+ Story</option>
                            </select>
                        </div>
                        <div class="config-group">
                            <label class="config-label">Difficulty</label>
                            <select class="config-select" id="difficulty" onchange="updateMaterialEstimate()">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                                <option value="extreme">Extreme</option>
                            </select>
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-group">
                            <label class="config-label">Profit Margin (%)</label>
                            <input type="number" class="config-input" id="profit-margin" value="35" min="0" max="100" onchange="updateMaterialEstimate()">
                        </div>
                        <div class="config-group">
                            <label class="config-label">Crew Count</label>
                            <select class="config-select" id="crew-count" onchange="updateMaterialEstimate()">
                                <option value="1" selected>1 Crew</option>
                                <option value="2">2 Crews</option>
                                <option value="3">3 Crews</option>
                                <option value="4">4 Crews</option>
                            </select>
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-group">
                            <label class="config-label">Light Spacing (inches)</label>
                            <select class="config-select" id="light-spacing" onchange="updateMaterialEstimate()">
                                <option value="6">6"</option>
                                <option value="12" selected>12"</option>
                                <option value="18">18"</option>
                                <option value="24">24"</option>
                            </select>
                        </div>
                        <div class="config-group">
                            <label class="config-label">Clip Spacing (inches)</label>
                            <select class="config-select" id="clip-spacing" onchange="updateMaterialEstimate()">
                                <option value="6">6"</option>
                                <option value="12" selected>12"</option>
                                <option value="18">18"</option>
                                <option value="24">24"</option>
                            </select>
                        </div>
                    </div>
                    <div class="config-row">
                        <div class="config-group">
                            <label class="config-label">Wire Buffer (%)</label>
                            <input type="number" class="config-input" id="wire-buffer" value="10" min="0" max="50" onchange="updateMaterialEstimate()">
                        </div>
                    </div>
                </div>
                
                <div class="material-items" id="material-items">
                    <div class="no-measurements">Start measuring to see material estimates</div>
                </div>
            </div>
        </div>
        
        <!-- Map Container -->
        <div class="map-container">
            <div id="map" class="loading">Loading Google Maps...</div>
            
            
            <!-- Live Stats Overlay -->
            <div class="live-stats" id="live-stats">
                <h4>Current Segment</h4>
                <div class="stat">
                    <span class="stat-label">Type:</span>
                    <span class="stat-value" id="current-type">perimeter</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Points:</span>
                    <span class="stat-value" id="current-points">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Distance:</span>
                    <span class="stat-value" id="current-distance">0.0 ft</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Replace with your Google Maps API key
        const API_KEY = 'AIzaSyBqiqFF63IrlciAk2qygXLg6Mf8Awln0-g';
        
        // Material costs
        const MATERIAL_COSTS = {
            light: 0.75,
            wire: 0.18,
            clip: 0.25
        };
        
        // Pricing Configuration
        const basePricing = {
            ledLight: 0.85,
            wire: 0.18,
            clip: 0.32,
            laborRate: 1.50
        };
        
        const complexityMultipliers = {
            stories: {
                1: 1.0,
                2: 1.3,
                3: 1.6
            },
            difficulty: {
                easy: 0.8,
                medium: 1.0,
                hard: 1.3,
                extreme: 1.6
            }
        };
        
        // State
        let map = null;
        let isMeasuring = false;
        let currentType = 'perimeter';
        let currentPoints = [];
        let measurements = [];
        let activePolyline = null;
        let savedPolylines = [];
        let savedMarkers = [];
        let clickListener = null;
        
        // Artificial zoom state
        let artificialZoomLevel = 0; // Extra zoom beyond Google Maps limits
        let baseMapZoom = 20; // Store the base Google Maps zoom level
        let mapScale = 1; // Current scale multiplier for artificial zoom
        
        // Zoom area tool state
        let zoomAreaMode = false;
        let zoomRectangle = null;
        let mouseDownListener = null;
        let mouseUpListener = null;
        
        // Colors
        const COLORS = {
            perimeter: '#ef4444',
            ridge: '#3b82f6',
            ground: '#10b981'
        };
        
        // ============================================
        // üîß PROFESSIONAL LOGGING SYSTEM
        // ============================================
        
        // Debug mode configuration
        const DEBUG_MODE = localStorage.getItem('measurementTool_debug') === 'true' || true; // Default enabled for development
        
        // Logging utility with emoji categories
        const logger = {
            debug: (message, data = null) => {
                if (!DEBUG_MODE) return;
                console.log(`üîß MeasurementTool: ${message}`, data ? data : '');
            },
            success: (message, data = null) => {
                if (!DEBUG_MODE) return;
                console.log(`‚úÖ MeasurementTool: ${message}`, data ? data : '');
            },
            warning: (message, data = null) => {
                console.warn(`‚ö†Ô∏è MeasurementTool: ${message}`, data ? data : '');
            },
            error: (message, data = null) => {
                console.error(`‚ùå MeasurementTool: ${message}`, data ? data : '');
            },
            result: (message, data = null) => {
                if (!DEBUG_MODE) return;
                console.log(`üéØ MeasurementTool: ${message}`, data ? data : '');
            },
            state: (message, data = null) => {
                if (!DEBUG_MODE) return;
                console.log(`üìä State: ${message}`, data ? data : '');
            },
            interaction: (message, data = null) => {
                if (!DEBUG_MODE) return;
                console.log(`üëÜ User Interaction: ${message}`, data ? data : '');
            }
        };
        
        // Application state logging
        const appState = {
            currentType: 'perimeter',
            isMeasuring: false,
            pointCount: 0,
            measurementCount: 0,
            lastAction: null,
            mapLoaded: false
        };
        
        function logStateChange(property, newValue, oldValue = null) {
            appState[property] = newValue;
            appState.lastAction = Date.now();
            logger.state(`${property} changed: ${oldValue} ‚Üí ${newValue}`, {
                fullState: { ...appState },
                timestamp: new Date().toISOString()
            });
        }

        // Load Google Maps
        function loadGoogleMaps() {
            logger.debug('Initializing Google Maps API');
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=geometry&callback=initMap`;
            script.async = true;
            script.defer = true;
            script.onload = () => logger.success('Google Maps API loaded successfully');
            script.onerror = () => logger.error('Failed to load Google Maps API');
            document.head.appendChild(script);
        }
        
        // Initialize map
        function initMap() {
            logger.debug('Initializing Google Maps instance');
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 31.9973, lng: -102.0779 }, // Midland, TX
                zoom: 20,
                mapTypeId: 'satellite',
                tilt: 0,
                disableDefaultUI: false,
                zoomControl: true,
                mapTypeControl: true,
                scaleControl: true,
                streetViewControl: true,
                rotateControl: true,
                fullscreenControl: true,
                gestureHandling: 'auto',
                backgroundColor: '#f5f5f5'
            });
            
            baseMapZoom = 20;
            logStateChange('mapLoaded', true, false);
            logger.success('Google Maps initialized successfully', {
                center: { lat: 31.9973, lng: -102.0779 },
                zoom: 20,
                mapType: 'satellite'
            });
            
            // Add map event listeners for debugging
            map.addListener('zoom_changed', function() {
                const currentZoom = map.getZoom();
                logger.debug(`Google Maps zoom changed: ${currentZoom}`, {
                    baseMapZoom: baseMapZoom,
                    artificialZoomLevel: artificialZoomLevel,
                    mapScale: mapScale
                });
            });
            
            map.addListener('center_changed', function() {
                const center = map.getCenter();
                logger.debug('Map center changed', {
                    lat: center.lat(),
                    lng: center.lng()
                });
            });
            
            // Add custom zoom area control to map
            addZoomAreaControl();
        }
        
        // Add custom zoom area control as Google Maps control
        function addZoomAreaControl() {
            // Create the DIV to hold the control
            const controlDiv = document.createElement('div');
            controlDiv.style.margin = '10px';
            
            // Create the control interior
            const controlUI = document.createElement('div');
            controlUI.className = 'zoom-area-control';
            controlUI.title = 'Select area to zoom into';
            controlUI.innerHTML = 'üîç';
            controlDiv.appendChild(controlUI);
            
            // Setup the click event listener
            controlUI.addEventListener('click', function() {
                activateZoomAreaTool();
            });
            
            // Position the control next to rotate controls (TOP_RIGHT)
            map.controls[google.maps.ControlPosition.TOP_RIGHT].push(controlDiv);
            
            logger.success('Zoom area control added to map');
        }
        
        // Activate zoom tool from sidebar button
        function activateZoomTool() {
            logger.interaction('Zoom Tool button clicked', {
                mapLoaded: !!map,
                currentZoomAreaMode: zoomAreaMode
            });
            
            if (!map) {
                logger.error('Zoom tool attempted before map initialization');
                alert('Please load a property first');
                return;
            }
            
            // Add visual feedback to zoom button
            const zoomButton = document.querySelector('.type-btn.zoom');
            if (zoomButton) {
                zoomButton.classList.add('clicked');
                setTimeout(() => {
                    zoomButton.classList.remove('clicked');
                }, 300);
            }
            
            // Activate the zoom area tool
            activateZoomAreaTool();
        }
        
        // Activate zoom area tool
        function activateZoomAreaTool() {
            if (!map) {
                alert('Please load a property first');
                return;
            }
            
            zoomAreaMode = !zoomAreaMode;
            
            // Update control appearance
            const zoomControl = document.querySelector('.zoom-area-control');
            if (zoomControl) {
                if (zoomAreaMode) {
                    zoomControl.classList.add('active');
                    zoomControl.title = 'Click and drag to select zoom area (Click again to exit)';
                } else {
                    zoomControl.classList.remove('active');
                    zoomControl.title = 'Select area to zoom into';
                }
            }
            
            if (zoomAreaMode) {
                logger.interaction('Zoom area tool activated');
                startZoomAreaSelection();
            } else {
                logger.interaction('Zoom area tool deactivated');
                stopZoomAreaSelection();
            }
        }
        
        // Start zoom area selection
        function startZoomAreaSelection() {
            // Clear any existing rectangle
            if (zoomRectangle) {
                zoomRectangle.setMap(null);
                zoomRectangle = null;
            }
            
            // Remove existing listeners
            if (mouseDownListener) google.maps.event.removeListener(mouseDownListener);
            if (mouseUpListener) google.maps.event.removeListener(mouseUpListener);
            
            let startPoint = null;
            
            // Add mouse down listener
            mouseDownListener = map.addListener('mousedown', function(event) {
                if (!zoomAreaMode) return;
                startPoint = event.latLng;
                logger.debug('Zoom area selection started', {
                    startPoint: { lat: startPoint.lat(), lng: startPoint.lng() }
                });
            });
            
            // Add mouse up listener
            mouseUpListener = map.addListener('mouseup', function(event) {
                if (!zoomAreaMode || !startPoint) return;
                
                const endPoint = event.latLng;
                logger.debug('Zoom area selection completed', {
                    startPoint: { lat: startPoint.lat(), lng: startPoint.lng() },
                    endPoint: { lat: endPoint.lat(), lng: endPoint.lng() }
                });
                
                // Create bounds for the selection
                const bounds = new google.maps.LatLngBounds();
                bounds.extend(startPoint);
                bounds.extend(endPoint);
                
                // Clear existing rectangle
                if (zoomRectangle) {
                    zoomRectangle.setMap(null);
                }
                
                // Create visual rectangle
                zoomRectangle = new google.maps.Rectangle({
                    bounds: bounds,
                    fillColor: '#f59e0b',
                    fillOpacity: 0.2,
                    strokeColor: '#f59e0b',
                    strokeOpacity: 0.8,
                    strokeWeight: 2,
                    map: map
                });
                
                // Zoom to the selected area
                map.fitBounds(bounds);
                
                // Apply additional artificial zoom after a short delay
                setTimeout(() => {
                    const currentZoom = map.getZoom();
                    if (currentZoom < 25) {
                        map.setZoom(Math.min(currentZoom + 3, 25));
                    }
                    logger.result('Zoom area applied', {
                        finalZoom: map.getZoom(),
                        artificialZoomApplied: currentZoom < 25
                    });
                }, 500);
                
                // Auto-deactivate tool after selection
                setTimeout(() => {
                    activateZoomAreaTool(); // This will toggle it off
                }, 1000);
                
                startPoint = null;
            });
            
            logger.debug('Zoom area selection listeners added');
        }
        
        // Stop zoom area selection
        function stopZoomAreaSelection() {
            // Remove listeners
            if (mouseDownListener) {
                google.maps.event.removeListener(mouseDownListener);
                mouseDownListener = null;
            }
            if (mouseUpListener) {
                google.maps.event.removeListener(mouseUpListener);
                mouseUpListener = null;
            }
            
            // Clear rectangle after a delay
            setTimeout(() => {
                if (zoomRectangle) {
                    zoomRectangle.setMap(null);
                    zoomRectangle = null;
                }
            }, 2000);
            
            logger.debug('Zoom area selection stopped and cleaned up');
        }
        
        // Search address
        function searchAddress() {
            const address = document.getElementById('address-input').value;
            const loadBtn = document.querySelector('.load-btn');
            
            logger.interaction('Load Property button clicked', { address: address });
            
            if (!address) {
                logger.warning('Address search attempted with empty address');
                alert('Please enter an address');
                return;
            }
            
            if (!map) {
                logger.error('Address search attempted before map initialization');
                alert('Map not yet loaded. Please wait...');
                return;
            }
            
            // Add loading state
            loadBtn.classList.add('loading');
            loadBtn.innerHTML = 'üîÑ Loading...';
            loadBtn.disabled = true;
            
            logger.debug('Starting geocoding request', { address: address });
            const geocoder = new google.maps.Geocoder();
            
            geocoder.geocode({ address: address }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    const oldZoom = artificialZoomLevel;
                    const oldScale = mapScale;
                    
                    // Reset artificial zoom when loading new address
                    artificialZoomLevel = 0;
                    mapScale = 1;
                    baseMapZoom = 20;
                    
                    logger.debug('Resetting artificial zoom for new address', {
                        oldZoom: oldZoom,
                        oldScale: oldScale,
                        newZoom: artificialZoomLevel,
                        newScale: mapScale
                    });
                    
                    // Clear any existing transforms
                    const mapDiv = map.getDiv();
                    if (mapDiv) {
                        mapDiv.style.transform = 'none';
                        mapDiv.style.transition = 'none';
                        
                        const mapContainer = mapDiv.querySelector('.gm-style > div:first-child');
                        if (mapContainer) {
                            mapContainer.style.transform = 'none';
                            mapContainer.style.transition = 'none';
                        }
                    }
                    
                    const location = results[0].geometry.location;
                    map.setCenter(location);
                    map.setZoom(20);
                    
                    logger.success('Address loaded successfully', {
                        address: address,
                        coordinates: {
                            lat: location.lat(),
                            lng: location.lng()
                        },
                        formattedAddress: results[0].formatted_address
                    });
                } else {
                    logger.error('Geocoding failed', {
                        address: address,
                        status: status,
                        resultsCount: results ? results.length : 0
                    });
                    alert('Address not found. Please try a different address.');
                }
                
                // Reset loading state
                loadBtn.classList.remove('loading');
                loadBtn.innerHTML = 'üè† Load Property';
                loadBtn.disabled = false;
            });
        }
        
        // Set measurement type
        function setType(type) {
            const oldType = currentType;
            logger.interaction(`Measurement type button clicked: ${type}`, {
                previousType: oldType,
                newType: type,
                isMeasuring: isMeasuring,
                pointCount: currentPoints.length
            });
            
            // Validate measurement type
            if (!['perimeter', 'ridge', 'ground'].includes(type)) {
                logger.error('Invalid measurement type selected', { type: type });
                return;
            }
            
            currentType = type;
            logStateChange('currentType', type, oldType);
            
            // Update UI elements
            document.getElementById('current-type').textContent = type;
            
            // Update button styles with logging
            document.querySelectorAll('.type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const selectedButton = document.querySelector(`.type-btn.${type}`);
            if (selectedButton) {
                selectedButton.classList.add('active');
                
                // Add visual click feedback
                selectedButton.classList.add('clicked');
                setTimeout(() => {
                    selectedButton.classList.remove('clicked');
                }, 300);
                
                logger.debug(`Button style updated: ${type} set to active`);
            } else {
                logger.warning(`Button not found for type: ${type}`);
            }
            
            logger.result(`Measurement type changed: ${oldType} ‚Üí ${type}`, {
                color: COLORS[type],
                isMeasuring: isMeasuring,
                currentPoints: currentPoints.length
            });
        }
        
        // Start measuring
        function startMeasuring() {
            logger.interaction('Start Measuring button clicked', {
                currentType: currentType,
                mapLoaded: !!map,
                isMeasuring: isMeasuring,
                existingPoints: currentPoints.length
            });
            
            if (!map) {
                logger.error('Start measuring attempted before map initialization');
                alert('Please load a property first');
                return;
            }
            
            const wasAlreadyMeasuring = isMeasuring;
            isMeasuring = true;
            currentPoints = [];
            
            logStateChange('isMeasuring', true, wasAlreadyMeasuring);
            logStateChange('pointCount', 0, currentPoints.length);
            
            logger.success(`Started measuring mode for ${currentType}`, {
                measurementType: currentType,
                color: COLORS[currentType],
                wasAlreadyMeasuring: wasAlreadyMeasuring
            });
            
            updateUI();
            
            // Add click listener with enhanced logging
            clickListener = map.addListener('click', (event) => {
                if (!isMeasuring) {
                    logger.warning('Map click detected but measuring mode is disabled');
                    return;
                }
                
                const newPoint = {
                    lat: event.latLng.lat(),
                    lng: event.latLng.lng()
                };
                
                const previousPointCount = currentPoints.length;
                currentPoints.push(newPoint);
                
                logger.debug(`Point ${currentPoints.length} added to ${currentType} measurement`, {
                    point: newPoint,
                    totalPoints: currentPoints.length,
                    measurementType: currentType
                });
                
                logStateChange('pointCount', currentPoints.length, previousPointCount);
                
                updateActivePolyline();
                updateLiveStats();
                
                // Log distance if we have enough points
                if (currentPoints.length >= 2) {
                    const distance = calculateDistance(currentPoints);
                    logger.result(`Current ${currentType} distance: ${distance.toFixed(1)} ft`, {
                        points: currentPoints.length,
                        distance: distance,
                        type: currentType
                    });
                }
            });
            
            logger.debug('Map click listener added for measurement mode');
        }
        
        // Update active polyline
        function updateActivePolyline() {
            if (currentPoints.length === 0) {
                if (activePolyline) {
                    activePolyline.setMap(null);
                    activePolyline = null;
                }
                return;
            }
            
            if (currentPoints.length === 1) {
                if (activePolyline) {
                    activePolyline.setMap(null);
                }
                activePolyline = new google.maps.Polyline({
                    path: currentPoints.map(pt => new google.maps.LatLng(pt.lat, pt.lng)),
                    geodesic: true,
                    strokeColor: COLORS[currentType],
                    strokeOpacity: 1,
                    strokeWeight: 3,
                    map: map
                });
            } else {
                if (activePolyline) {
                    activePolyline.setPath(currentPoints.map(pt => new google.maps.LatLng(pt.lat, pt.lng)));
                }
            }
        }
        
        // Calculate distance
        function calculateDistance(points) {
            if (points.length < 2) return 0;
            
            let total = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(points[i].lat, points[i].lng),
                    new google.maps.LatLng(points[i + 1].lat, points[i + 1].lng)
                );
                total += distance;
            }
            
            return total * 3.28084; // Convert to feet
        }
        
        // Save measurement
        function saveMeasurement() {
            if (currentPoints.length < 2) {
                alert('Need at least 2 points to save a measurement');
                return;
            }
            
            const measurement = {
                type: currentType,
                points: currentPoints,
                distance: calculateDistance(currentPoints)
            };
            
            measurements.push(measurement);
            
            if (activePolyline) {
                activePolyline.setMap(null);
                activePolyline = null;
            }
            
            currentPoints = [];
            isMeasuring = false;
            
            if (clickListener) {
                google.maps.event.removeListener(clickListener);
            }
            
            drawAllMeasurements();
            updateDistanceResults();
            updateMaterialEstimate();
            updateUI();
        }
        
        // Draw all saved measurements
        function drawAllMeasurements() {
            // Clear existing
            savedPolylines.forEach(p => p.setMap(null));
            savedMarkers.forEach(m => m.setMap(null));
            savedPolylines = [];
            savedMarkers = [];
            
            measurements.forEach(measurement => {
                const color = COLORS[measurement.type];
                
                // Polyline
                const polyline = new google.maps.Polyline({
                    path: measurement.points.map(pt => new google.maps.LatLng(pt.lat, pt.lng)),
                    geodesic: true,
                    strokeColor: color,
                    strokeOpacity: 1,
                    strokeWeight: 3,
                    map: map
                });
                savedPolylines.push(polyline);
                
                // Markers
                measurement.points.forEach(point => {
                    const marker = new google.maps.Marker({
                        position: new google.maps.LatLng(point.lat, point.lng),
                        map: map,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 3,
                            fillColor: color,
                            fillOpacity: 1,
                            strokeColor: '#ffffff',
                            strokeWeight: 1
                        },
                        clickable: false,
                        optimized: false,
                        zIndex: -100
                    });
                    savedMarkers.push(marker);
                });
            });
        }
        
        // Undo point
        function undoPoint() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
                updateActivePolyline();
                updateLiveStats();
            }
        }
        
        // Clear current
        function clearCurrent() {
            currentPoints = [];
            if (activePolyline) {
                activePolyline.setMap(null);
                activePolyline = null;
            }
            isMeasuring = false;
            if (clickListener) {
                google.maps.event.removeListener(clickListener);
            }
            updateUI();
        }
        
        // Update UI
        function updateUI() {
            const startBtn = document.getElementById('start-btn');
            const controlRow = document.getElementById('control-row');
            const liveStats = document.getElementById('live-stats');
            
            if (isMeasuring) {
                startBtn.style.display = 'none';
                controlRow.style.display = 'flex';
                liveStats.style.display = 'block';
            } else {
                startBtn.style.display = 'block';
                controlRow.style.display = 'none';
                liveStats.style.display = 'none';
            }
        }
        
        // Update live stats
        function updateLiveStats() {
            document.getElementById('current-points').textContent = currentPoints.length;
            const distance = calculateDistance(currentPoints);
            document.getElementById('current-distance').textContent = distance.toFixed(1) + ' ft';
        }
        
        // Update distance results
        function updateDistanceResults() {
            const perimeterDist = measurements.filter(m => m.type === 'perimeter').reduce((sum, m) => sum + m.distance, 0);
            const ridgeDist = measurements.filter(m => m.type === 'ridge').reduce((sum, m) => sum + m.distance, 0);
            const groundDist = measurements.filter(m => m.type === 'ground').reduce((sum, m) => sum + m.distance, 0);
            const totalDist = perimeterDist + ridgeDist + groundDist;
            
            let html = '';
            if (perimeterDist > 0) {
                html += `<div class="result-item perimeter">
                    <span class="result-label">üî¥ Perimeter</span>
                    <span class="result-value">${perimeterDist.toFixed(1)} ft</span>
                </div>`;
            }
            if (ridgeDist > 0) {
                html += `<div class="result-item ridge">
                    <span class="result-label">üîµ Ridge</span>
                    <span class="result-value">${ridgeDist.toFixed(1)} ft</span>
                </div>`;
            }
            if (groundDist > 0) {
                html += `<div class="result-item ground">
                    <span class="result-label">üü¢ Ground</span>
                    <span class="result-value">${groundDist.toFixed(1)} ft</span>
                </div>`;
            }
            if (totalDist > 0) {
                html += `<div class="result-item total">
                    <span class="result-label">Total Distance</span>
                    <span class="result-value">${totalDist.toFixed(1)} ft</span>
                </div>`;
            }
            
            document.getElementById('distance-results').innerHTML = html || '<div class="no-measurements">No measurements yet</div>';
        }
        
        // Update material estimate
        function updateMaterialEstimate() {
            const totalDist = measurements.reduce((sum, m) => sum + m.distance, 0);
            
            logger.debug('Updating material estimate calculation', {
                totalDistance: totalDist,
                measurementCount: measurements.length,
                measurementBreakdown: measurements.map(m => ({
                    type: m.type,
                    distance: m.distance.toFixed(1)
                }))
            });
            
            if (totalDist === 0) {
                logger.debug('No measurements available for material calculation');
                document.getElementById('material-items').innerHTML = '<div class="no-measurements">Start measuring to see material estimates</div>';
                return;
            }
            
            // Get configuration values
            const lightSpacing = parseInt(document.getElementById('light-spacing').value);
            const clipSpacing = parseInt(document.getElementById('clip-spacing').value);
            const wireBuffer = parseInt(document.getElementById('wire-buffer').value);
            const crewCount = parseInt(document.getElementById('crew-count').value);
            const profitMargin = parseInt(document.getElementById('profit-margin').value) / 100;
            const stories = parseInt(document.getElementById('stories').value);
            const difficulty = document.getElementById('difficulty').value;
            
            logger.debug('Using material calculation parameters', {
                lightSpacing: lightSpacing,
                clipSpacing: clipSpacing,
                wireBuffer: wireBuffer,
                crewCount: crewCount,
                profitMargin: (profitMargin * 100).toFixed(0) + '%',
                stories: stories,
                difficulty: difficulty
            });
            
            // Calculate quantities
            const lightsNeeded = Math.ceil((totalDist * 12) / lightSpacing);
            const wireLength = Math.ceil(totalDist * (1 + wireBuffer / 100));
            const clipsNeeded = Math.ceil((totalDist * 12) / clipSpacing);
            
            // Calculate costs with business logic
            const lightsCost = lightsNeeded * basePricing.ledLight;
            const clipsCost = clipsNeeded * basePricing.clip;
            const wireCost = wireLength * basePricing.wire;
            
            // Calculate labor with complexity
            const storyMultiplier = complexityMultipliers.stories[stories];
            const difficultyMultiplier = complexityMultipliers.difficulty[difficulty];
            const laborCost = totalDist * basePricing.laborRate * storyMultiplier * difficultyMultiplier * crewCount;
            
            const subtotal = lightsCost + clipsCost + wireCost + laborCost;
            const profit = subtotal * profitMargin;
            const total = subtotal + profit;
            
            logger.result('Material calculation completed', {
                quantities: {
                    lights: lightsNeeded,
                    wire: wireLength + ' ft',
                    clips: clipsNeeded
                },
                costs: {
                    lights: '$' + lightsCost.toFixed(2),
                    clips: '$' + clipsCost.toFixed(2),
                    wire: '$' + wireCost.toFixed(2),
                    labor: '$' + laborCost.toFixed(2),
                    subtotal: '$' + subtotal.toFixed(2),
                    profit: '$' + profit.toFixed(2),
                    total: '$' + total.toFixed(2)
                },
                multipliers: {
                    story: storyMultiplier,
                    difficulty: difficultyMultiplier
                }
            });
            
            const html = `
                <div class="result-item perimeter">
                    <span class="result-label">üí° LED Lights</span>
                    <span class="result-value">${lightsNeeded} ($${lightsCost.toFixed(2)})</span>
                </div>
                
                <div class="result-item ridge">
                    <span class="result-label">üîå Wire Length</span>
                    <span class="result-value">${wireLength} ft ($${wireCost.toFixed(2)})</span>
                </div>
                
                <div class="result-item ground">
                    <span class="result-label">üìé Clips</span>
                    <span class="result-value">${clipsNeeded} ($${clipsCost.toFixed(2)})</span>
                </div>
                
                <div class="result-item perimeter">
                    <span class="result-label">üë∑ Installation Labor</span>
                    <span class="result-value">$${laborCost.toFixed(2)}</span>
                </div>
                
                <div class="result-item ridge">
                    <span class="result-label">üí∞ Profit (${(profitMargin * 100).toFixed(0)}%)</span>
                    <span class="result-value">$${profit.toFixed(2)}</span>
                </div>
                
                <div class="result-item total" style="margin-top: 8px;">
                    <span class="result-label">Total Quote</span>
                    <span class="result-value">$${total.toFixed(2)}</span>
                </div>
            `;
            
            document.getElementById('material-items').innerHTML = html;
        }
        
        // Artificial zoom in - beyond Google Maps limits
        function artificialZoomIn() {
            if (!map) return;
            
            // Always use artificial zoom - don't rely on Google's limits
            artificialZoomLevel++;
            mapScale = Math.pow(1.5, artificialZoomLevel); // Use 1.5x multiplier for smoother zoom
            applyArtificialZoom();
            
            console.log(`Artificial zoom level: ${artificialZoomLevel}, scale: ${mapScale.toFixed(2)}x`);
        }
        
        // Artificial zoom out
        function artificialZoomOut() {
            if (!map) return;
            
            if (artificialZoomLevel > 0) {
                artificialZoomLevel--;
                mapScale = artificialZoomLevel > 0 ? Math.pow(1.5, artificialZoomLevel) : 1;
                applyArtificialZoom();
                
                console.log(`Artificial zoom level: ${artificialZoomLevel}, scale: ${mapScale.toFixed(2)}x`);
            }
        }
        
        // Apply artificial zoom using CSS transform
        function applyArtificialZoom() {
            const mapDiv = map.getDiv();
            if (!mapDiv) return;
            
            // Find the actual map tiles container
            const mapContainer = mapDiv.querySelector('.gm-style > div:first-child');
            
            if (mapContainer) {
                if (artificialZoomLevel > 0) {
                    mapContainer.style.transform = `scale(${mapScale})`;
                    mapContainer.style.transformOrigin = 'center center';
                    mapContainer.style.transition = 'transform 0.2s ease-out';
                } else {
                    mapContainer.style.transform = 'none';
                    mapContainer.style.transition = 'none';
                }
            } else {
                // Fallback: apply to the entire map div
                if (artificialZoomLevel > 0) {
                    mapDiv.style.transform = `scale(${mapScale})`;
                    mapDiv.style.transformOrigin = 'center center';
                    mapDiv.style.transition = 'transform 0.2s ease-out';
                } else {
                    mapDiv.style.transform = 'none';
                    mapDiv.style.transition = 'none';
                }
            }
        }
        
        // ============================================
        // üõ†Ô∏è DEBUG MODE TOGGLE & CONSOLE HELPERS
        // ============================================
        
        // Toggle debug mode
        function toggleDebugMode() {
            const newMode = !DEBUG_MODE;
            localStorage.setItem('measurementTool_debug', newMode.toString());
            logger.success(`Debug mode ${newMode ? 'enabled' : 'disabled'}`, {
                mode: newMode ? 'ENABLED' : 'DISABLED',
                note: 'Refresh page to apply changes'
            });
            return newMode;
        }
        
        // Global measurement tool object for console debugging
        window.measurementTool = {
            // State inspection
            getState: () => ({ ...appState }),
            getCurrentType: () => currentType,
            getMeasurements: () => measurements,
            getCurrentPoints: () => currentPoints,
            getMap: () => map,
            
            // Debug controls
            toggleDebug: toggleDebugMode,
            enableDebug: () => {
                localStorage.setItem('measurementTool_debug', 'true');
                logger.success('Debug mode enabled - refresh page to apply');
            },
            disableDebug: () => {
                localStorage.setItem('measurementTool_debug', 'false');
                logger.success('Debug mode disabled - refresh page to apply');
            },
            
            // Utility functions
            clearAllMeasurements: () => {
                measurements.length = 0;
                savedPolylines.forEach(p => p.setMap(null));
                savedMarkers.forEach(m => m.setMap(null));
                savedPolylines.length = 0;
                savedMarkers.length = 0;
                updateDistanceResults();
                updateMaterialEstimate();
                logger.success('All measurements cleared');
            },
            
            // Pricing information
            getPricing: () => ({ basePricing, complexityMultipliers, COLORS }),
            
            // Performance timing
            startTimer: (name) => {
                console.time(name);
                logger.debug(`Timer started: ${name}`);
            },
            endTimer: (name) => {
                console.timeEnd(name);
                logger.debug(`Timer ended: ${name}`);
            }
        };

        // Load maps on page load
        window.onload = () => {
            logger.debug('Window loaded, initializing application');
            loadGoogleMaps();
            
            // Show console helper message
            if (DEBUG_MODE) {
                console.log(`
üîß Measurement Tool Debug Mode Active
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Available Console Commands:
‚Ä¢ measurementTool.getState()          - View current application state
‚Ä¢ measurementTool.getMeasurements()   - View all saved measurements  
‚Ä¢ measurementTool.toggleDebug()       - Toggle debug logging
‚Ä¢ measurementTool.clearAllMeasurements() - Clear all measurements
‚Ä¢ measurementTool.getPricing()        - View pricing configuration

Debug Categories:
üîß Debug messages
‚úÖ Success events  
‚ö†Ô∏è Warnings
‚ùå Errors
üéØ Results & calculations
üìä State changes
üëÜ User interactions
                `);
            }
        };
    </script>
</body>
</html>